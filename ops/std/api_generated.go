package stdops

import "gorgonia.org/gorgonia/ops"

// Code generated by genops, which is a ops generation tool for Gorgonia. DO NOT EDIT.

// Add creates an ops.Op that is correct to the shape of the given operands.
func Add(a, b ops.Operand) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return addVV{}
	case !aScalar && bScalar:
		return addVS{}
	case aScalar && !bScalar:
		return addSV{}
	}
}

// Sub creates an ops.Op that is correct to the shape of the given operands.
func Sub(a, b ops.Operand) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return subVV{}
	case !aScalar && bScalar:
		return subVS{}
	case aScalar && !bScalar:
		return subSV{}
	}
}

// Mul creates an ops.Op that is correct to the shape of the given operands.
func Mul(a, b ops.Operand) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return mulVV{}
	case !aScalar && bScalar:
		return mulVS{}
	case aScalar && !bScalar:
		return mulSV{}
	}
}

// Div creates an ops.Op that is correct to the shape of the given operands.
func Div(a, b ops.Operand) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return divVV{}
	case !aScalar && bScalar:
		return divVS{}
	case aScalar && !bScalar:
		return divSV{}
	}
}

// Pow creates an ops.Op that is correct to the shape of the given operands.
func Pow(a, b ops.Operand) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return powVV{}
	case !aScalar && bScalar:
		return powVS{}
	case aScalar && !bScalar:
		return powSV{}
	}
}

// Mod creates an ops.Op that is correct to the shape of the given operands.
func Mod(a, b ops.Operand) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return modVV{}
	case !aScalar && bScalar:
		return modVS{}
	case aScalar && !bScalar:
		return modSV{}
	}
}

// Lt creates an ops.Op that is correct to the shape of the given operands.
func Lt(a, b ops.Operand, retSame bool) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return ltVV{ltOp{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return ltVS{ltOp{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return ltSV{ltOp{retSame: retSame}, binopSV{}}
	}
}

// Lte creates an ops.Op that is correct to the shape of the given operands.
func Lte(a, b ops.Operand, retSame bool) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return lteVV{lteOp{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return lteVS{lteOp{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return lteSV{lteOp{retSame: retSame}, binopSV{}}
	}
}

// Gt creates an ops.Op that is correct to the shape of the given operands.
func Gt(a, b ops.Operand, retSame bool) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gtVV{gtOp{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return gtVS{gtOp{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return gtSV{gtOp{retSame: retSame}, binopSV{}}
	}
}

// Gte creates an ops.Op that is correct to the shape of the given operands.
func Gte(a, b ops.Operand, retSame bool) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return gteVV{gteOp{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return gteVS{gteOp{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return gteSV{gteOp{retSame: retSame}, binopSV{}}
	}
}

// ElEq creates an ops.Op that is correct to the shape of the given operands.
func ElEq(a, b ops.Operand, retSame bool) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elEqVV{elEqOp{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return elEqVS{elEqOp{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return elEqSV{elEqOp{retSame: retSame}, binopSV{}}
	}
}

// ElNe creates an ops.Op that is correct to the shape of the given operands.
func ElNe(a, b ops.Operand, retSame bool) ops.Op {
	aScalar := a.Shape().IsScalar()
	bScalar := b.Shape().IsScalar()

	switch {
	default:
		fallthrough
	case !aScalar && !bScalar:
		return elNeVV{elNeOp{retSame: retSame}, binopVV{}}
	case !aScalar && bScalar:
		return elNeVS{elNeOp{retSame: retSame}, binopVS{}}
	case aScalar && !bScalar:
		return elNeSV{elNeOp{retSame: retSame}, binopSV{}}
	}
}
